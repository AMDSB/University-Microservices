import assert from 'assert';
import fs from 'fs';
import path, { resolve } from 'path';
import { globbySync, isDynamicPattern } from 'globby';
import multimatch from 'multimatch';
import normalize from 'normalize-path';
import File from 'vinyl';
import { getCommonPath, globify, render } from '../util.js';
function applyProcessingFunc(process, contents, filename, destination) {
    const output = process(contents, filename, destination);
    return Buffer.isBuffer(output) ? output : Buffer.from(output);
}
export function copy(from, to, options, context, tplSettings) {
    to = path.resolve(to);
    options = options ?? {};
    const { fromBasePath } = options;
    if (fromBasePath) {
        const applyBasePath = (from) => (path.isAbsolute(from) ? from : path.resolve(fromBasePath, from));
        from = Array.isArray(from) ? from.map(applyBasePath) : applyBasePath(from);
    }
    let files = [];
    if (options.noGlob) {
        const fromFiles = Array.isArray(from) ? from : [from];
        files = fromFiles.filter((filepath) => this.store.existsInMemory(filepath) || fs.existsSync(filepath));
    }
    else {
        const fromGlob = globify(from);
        const globOptions = { ...options.globOptions, nodir: true };
        const diskFiles = globbySync(fromGlob, globOptions).map((file) => path.resolve(file));
        const storeFiles = [];
        this.store.each((file) => {
            const normalizedFilepath = normalize(file.path);
            // The store may have a glob path and when we try to copy it will fail because not real file
            if (!diskFiles.includes(file.path) &&
                !isDynamicPattern(normalizedFilepath) &&
                multimatch([normalizedFilepath], fromGlob).length !== 0) {
                storeFiles.push(file.path);
            }
        });
        files = diskFiles.concat(storeFiles);
    }
    let generateDestination = () => to;
    if (Array.isArray(from) || !this.exists(from) || (isDynamicPattern(normalize(from)) && !options.noGlob)) {
        assert(!this.exists(to) || fs.statSync(to).isDirectory(), 'When copying multiple files, provide a directory as destination');
        const processDestinationPath = options.processDestinationPath || ((path) => path);
        const root = fromBasePath ?? getCommonPath(from);
        generateDestination = (filepath) => {
            const toFile = path.relative(root, filepath);
            return processDestinationPath(path.join(to, toFile));
        };
    }
    // Sanity checks: Makes sure we copy at least one file.
    assert(